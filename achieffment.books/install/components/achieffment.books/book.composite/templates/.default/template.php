<?php
if (!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();

$this->setFrameMode(true);

/*
    Курс:
    https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=39&INDEX=Y

    В режиме Автокомпозита добавление новых страниц на сайте автоматически подключает их к технологии.
    В режиме Композита каждую новую страницу нужно настраивать на работу в этом режиме.
    Страница будет работать в композитном режиме, только когда все компоненты и шаблоны на ней будут корректно настроены.

    При выборе Автокомпозит система сама назначает следующие параметры:
        Голосование шаблона компонента по умолчанию - за;
        Содержимое компонента - Автоматически формирующаяся динамическая область с заглушкой;
        Режим перезаписи кеша - Стандартный режим с задержкой перезаписи.

    Действия разработчика после включения режима Автокомпозит:
        При выборе автоматического режима становятся ненужными все работы по настройке компонентов: все неадаптированные компоненты автоматически создают динамические области с заглушкой в виде своего содержимого.
    Они автоматически голосуют "за", автоматически происходит разметка динамических зон.
    Если нужен какой-то иной режим работы компонента на какой либо странице, то изменить параметры работы можно в настройках самого компонента. При этом возможности выбора типа заглушки через компонент больше, чем в настройках страницы Настройки > Настройки продукта > Композитный сайт:

    Условия и проблемы:
        Если javascript-код большой и не запускается, то инициализация кода должна быть на событии DOMContentLoaded, которое находится в статических js-файлах, как правило инициализация осуществляется либо BX.ready, либо ready от jQuery. Перенесите BX.ready или $.ready в саму динамическую область.
    Отложенных функций не должно быть в динамической области (ShowTitle и т.п.)

    Отладка:
        Список всех сохранённых кешей страниц отображается на Настройки > Настройки продукта > Композитный сайт > Страницы
        Если работы по композитной технологии произведены верно, то страницу можно найти в этом списке. Если страницы нет, то надо включать Отладку и искать причины.
    Основной инструмент отладки - это страница Настройки > Настройки продукта > Композитный сайт > Отладка, на которой производится логирование всех ошибок
        Установка константы будет писать в лог все голосования компонентов против (необходимо для отладки), установка происходит по пути:
            /bitrix/php_interface/dbconn.php
        Необходимо внести константы:
            define("LOG_FILENAME", $_SERVER["DOCUMENT_ROOT"] . "/log.txt"); - путь к файлу лога
            define("BX_COMPOSITE_DEBUG", true); - включение режима отладки
        По данным можно определить какой файл и какой компонент был вызван, если они записываются в лог, значит происходит голосование против, также возможно, что кеш перезаписывается после каждой перезагрузки, необходимо проверить компоненты и исправить ошибки. Когда лог будет пуст, значит, что ошибок нет.

    Если компонент сам находится в динамической области, он всегда голосует за. Кроме этого есть возможность помечать определённые области, как постоянно голосующие за.
    $staticHTMLCache = \Bitrix\Main\Data\StaticHTMLCache::getInstance();
        $staticHTMLCache->disableVoting(); // Выключаем голосование
        $APPLICATION->includeComponent("mycompany:mycomponent", "template", array(), null, array()); //компонент и шаблон не участвуют в голосовании
        $staticHTMLCache->enableVoting();  // Включаем после компонента

    Функция, которая устанавливает голосование компонента за или против композитный сайт:
        $this->setFrameMode(false|true);
    Её можно использовать как в самом компоненте, так и в шаблоне
    Компонент по умолчанию голосует за, но если необходимо задать явно, чтобы он голосовал против, то следует задать данную функцию, это может быть необходимо при работе с некоторыми компонентами, например компонент список результатов поиска, т.к. она всегда отдает разные данные и кешировать их смысла нет.
    Если компонент или шаблон голосует против, то страница с таким компонентом никогда не будет работать в рамках технологии.
    Шаблоны по умолчанию голосуют против.
    Если шаблон компонента отдается из кеша (через $this->StartResultCache()) и при этом шаблон голосовал "против", то композитный режим будет отменен.

    Если в компоненте достаточно указать:
        $this->setFrameMode(true);
    То кеширование шаблонов немного сложнее, их может быть 3 вида:
        1. Статичный - когда шаблон можно сложить в кеш
        2. Динамический - когда контент постоянно изменяется и складывать его в кеш бесполезно
        3. Статичный с динамическими вставками - когда шаблон можно сложить в кеш, но его часть может меняться, то есть имеет динамические зоны

    1. При статичном кеше для голосования шаблона компонента за, достаточно в начале шаблона указать:
        $this->setFrameMode(true);
    Тогда весь шаблон компонента будет складываться в кеш.

    2. При динамическом контенте для голосования шаблона компонента за, необходимо указать:
        $this->createFrame()->begin("Загрузка");

    Функция автоматически устанавливает $this->setFrameMode(true);, она определяет начало контента с динамической зоной, если такой тег нигде не завершается, то весь шаблон компонента определяется как динамическая зона и не складывается в кеш.
    В заглушке будет указано слово "Загрузка", переданное при объявлении функции

    Если нужна "пустая заглушка", то укажите пустую строку:
        $this->createFrame()->begin("");
    Если необходимо чтобы в "заглушке" отображались данные компонента, полученные на предыдущем хите, то begin необходимо вызвать без параметров:
        $frame = $this->createFrame()->begin();
    В качестве параметра можно использовать не только строки, но и html-контент, например изображения:
	    $this->createFrame()->begin("<img src=".png" />");

    Чтобы завершить динамеческую область:
        $frame->end();

    3. При статическом контенте с динамичными зонами, например, блок с популярными товарами. Сам контент является статичным, но цены могут меняться в зависимости от пользователя (например, при применении скидок на определнную группу). Такой контент необходимо разделять, чтобы отображалась корректная информация для каждого пользователя и кеш не сбрасывался.

    Блок с ценой необходимо обрамлять как:
        $frame = $this->createFrame()->begin();
        // Контент
        $frame->beginStub();
        // Заглушка
        $frame->end();

    Если необходимо задать оформление динамической области, то можно передать айди контейнера:
        $frame = $this->createFrame("sale-basket-basket-line-container", false)->begin();
    Если мы используем в цикле, то можно передавать айди цены, например:
        $frame = $this->createFrame($arItemIds["PRICE"], false)->begin();

    Важно понимать, что код между вызовами begin-beginStub и beginStub-end выполняется всегда. И на первом хите к странице (на котором создается кеш) и на аякс-хите. Эти методы занимаются буферизацией контента и не являются аналогами конструкции if-else.

    Динамичных зон в шаблоне компонента может быть несколько, но они не могут быть вложенными друг в друга.

    Можно создавать динамические области и в других частях сайта, если в шаблоне самого сайта или на странице задан какой-то код, например, при использовании функции time() и её выводе контент будет постоянно меняться, значит будет и сбрасываться кеш, то есть логично поместить эту часть в динамическую область:
        $dynamicArea = new \Bitrix\Main\Page\FrameStatic("my_dynamic");
        $dynamicArea->setAnimation(true);
        $dynamicArea->setStub("заглушка");
        $dynamicArea->setContainerID("my-div-id");
        $dynamicArea->startDynamicArea();
        // Содержимое динамической области
        // HTML, PHP, подключение компонентов
        $dynamicArea->finishDynamicArea();

    В режиме Автокомпозит используется новый алгоритм разметки динамических областей, который не влияет на используемый дизайн на сайте. Вместо div-контейнера, создается пара невидимых тегов, не влияющих на верстку страницы.
        <div id="bxdynamic_area_id_start" style="display:none"></div>
    Контент заглушки
        <div id="bxdynamic_area_id_end" style="display:none"></div>
*/

if (!empty($arResult)) {
    $i = 0;
    foreach ($arResult as $item) {
        // Т.к. template это уже другой объект, то обратиться по this мы не можем, но есть переменная component, которая указывает на экземпляр компонента
        $component->printArray($item);
        $frame = $this->createFrame("example_container_".$i, false)->begin();
        echo "Динамическая информация #" . $i;
        $frame->beginStub();
        echo "Заглушка";
        $frame->end();
        $i++;
    }
}
?>
