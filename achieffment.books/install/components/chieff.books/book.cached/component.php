<? if (!defined("B_PROLOG_INCLUDED") || B_PROLOG_INCLUDED!==true)die();

if ($this->checkModule()) {

    if ($arParams["SET_TITLE"] == "Y")
        $APPLICATION->SetTitle("Скелет модуля - Модуль книг - Компонент с кешированием");

    // Зачем кешировать?
    // Если выполняется большой запрос, который подгружает кучу записей из бд, потом по ним ещё и строится HTML - небыстрый процесс, если данных много
    // А если вдобавок много посетителей? Сайт может просто лечь, тупить, медленно работать, т.к. для каждого будет выполняться множество операций и запросов
    // Когда операции закешированы, то можно сразу получить результат как уже сгенерированной верстки, так и выполненных операций, которые не нужно заново проделывать и производить вычисления, запросы

    // По умолчанию компоненты ничего не кешируют, кеширование нужно задавать самостоятельно

    // В компонентах используется "Авто + Управляемое" или Кешировать"
    // Авто обозначает обычное кеширование обновляется спустя определенный промежуток времени
    // Технология управляемого кеширования или тегированный кеш (Сache Dependencies) автоматически обновляет кеш компонентов при изменении данных. Если управляемое кеширование включено, вам не потребуется вручную обновлять кеш компонентов, например, при изменении новостей или товаров, изменения сразу станут видны посетителям сайта. Управляемый кеш хранится в файлах каталога /bitrix/managed_cache/. Для часто обновляемого большого массива данных использование тегированного кеша неоправданно, лучше использовать неуправляемое кеширование.
    // Кешировать - неуправляемое кеширование - обновляется спустя определенный промежуток времени

    // Кеширование в компонентах выполняется с помощью
    // bool $this->StartResultCache($cacheTime = False, $additionalCacheID = False, $cachePath = False)
    // Первым задается время кеширования, если False, то подставляется из $arParams["CACHE_TIME"]
    // Вторым айди кеша (формируется автоматически из имени сайта, имени компонента и входных параметров), если необходимо что-то ещё, то нужно передавать массивом элементов, при изменении параметра, меняется айди, соответственно кеш сбрасывается
    // Путь к файлу кеша (если False - подставляется "/" . SITE_ID . <путь к компоненту относительно bitrix/components>).
    // По умолчанию путь получится примерно такой: /bitrix/cache/s1/achieffment.books/book
    // Если есть валидный кеш, то метод отправляет на экран его содержимое, заполняет $arResult и возвращает False; если нет валидного кеша, то он возвращает True.
    // Если в процессе может выясниться, что кешировать не надо, то $this->AbortResultCache(); - отменит кеширование
    // $this->ClearResultCache($additionalCacheID = False, $cachePath = False) - чистит кеш

    // Обычное кеширование в компонентах:
    // Передадим время кеширование из параметров
    $ttl = $arParams["CACHE_TIME"];
    // Передадим ключ для кеша
    // Проверим есть ли параметр у комопнента о дополнительной проверке доступа
    $bUSER_HAVE_ACCESS = $arParams["USE_PERMISSIONS"] ?? "";
    // Сформируем ключ кеша в зависимости от того, включена ли проверка групп, которым принадлежит пользователь и от созданной переменной
    $cacheKey = array(($arParams["CACHE_GROUPS"] === "N" ? false : $USER->GetGroups()), $bUSER_HAVE_ACCESS);
    // Передадим путь относительно папки /bitrix/cache/
    $cachePath = "/" . SITE_ID . $this->GetRelativePath();
    // Если нет валидного кеша (то есть нужно запросить данные и сделать валидный кеш), то заходим в скрипт
    if ($this->StartResultCache($ttl, $cacheKey, $cachePath)) {
        // Делаем запросы и формируем $arResult
        $arResult["ITEMS"] = $this->getAll();
        // Если $arResult очень большой, но нужно кешировать конкретные ключи, то их можно задать методом ниже, передав массив ключей
        // Вызывают в самом конце перед подключением шаблона
        // $this->SetResultCacheKeys(array("ID", "~ID", "SORT", "~SORT"));
        // Кеширование завершается и кеш сохраняется при вызове методов CBitrixComponent::IncludeComponentTemplate или CBitrixComponent::ShowComponentTemplate сразу после подключения шаблона компонента.
        // Если в шаблоне потребуется вызвать другой компонент, то нужно передать ему родителем текущий компонент, компонент станет комплексным и стили смогут подключиться
        // Это обязательно делать, чтобы связать теги кеша текущего компонента и вложенного, чтобы они могли чиститься вместе
        // Кеширование у вложенного компонента можно не включать, компонент родитель его всё равно закеширует, если включаем, то время кеширования стоит передавать как $arParams["CACHE_TIME"]
        $this->IncludeComponentTemplate();
    }

}

?>